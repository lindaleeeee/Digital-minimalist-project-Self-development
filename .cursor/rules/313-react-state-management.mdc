---
description: State management patterns and best practices for React applications
globs: ["**/store/**", "**/context/**", "**/hooks/**"]
alwaysApply: false
---
# React State Management Rules

## State Management Strategy

### Local State (useState)
Use for component-specific state that doesn't need sharing:
```typescript
const [isOpen, setIsOpen] = useState(false);
const [formData, setFormData] = useState({ name: '', email: '' });
```

### Lifted State (Props)
Use for state shared between siblings or close relatives:
```typescript
// Parent component manages state
function HabitList() {
  const [selectedHabit, setSelectedHabit] = useState<Habit | null>(null);
  
  return (
    <>
      <HabitGrid habits={habits} onSelect={setSelectedHabit} />
      <HabitDetail habit={selectedHabit} />
    </>
  );
}
```

### Context (React.createContext)
Use for global state accessed by many components (theme, auth, i18n):
```typescript
// auth-context.tsx
interface AuthContextValue {
  user: User | null;
  login: (credentials: Credentials) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  
  const login = async (credentials: Credentials) => {
    const user = await authService.login(credentials);
    setUser(user);
  };
  
  const logout = () => setUser(null);
  
  const value = useMemo(
    () => ({ user, login, logout, isAuthenticated: !!user }),
    [user]
  );
  
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
```

### External State (Zustand/Redux)
Use for complex global state with advanced features:
```typescript
// Using Zustand (recommended for simplicity)
import create from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface HabitStore {
  habits: Habit[];
  addHabit: (habit: Habit) => void;
  removeHabit: (id: string) => void;
  fetchHabits: () => Promise<void>;
}

export const useHabitStore = create<HabitStore>()(
  devtools(
    persist(
      (set, get) => ({
        habits: [],
        addHabit: (habit) => set((state) => ({ 
          habits: [...state.habits, habit] 
        })),
        removeHabit: (id) => set((state) => ({ 
          habits: state.habits.filter(h => h.id !== id) 
        })),
        fetchHabits: async () => {
          const habits = await habitService.getAll();
          set({ habits });
        },
      }),
      { name: 'habit-store' }
    )
  )
);
```

## Server State (React Query/SWR)
Use for data fetched from APIs:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Fetch habits
function useHabits(userId: string) {
  return useQuery({
    queryKey: ['habits', userId],
    queryFn: () => habitService.getByUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

// Create habit
function useCreateHabit() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (habit: HabitInput) => habitService.create(habit),
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['habits'] });
    },
  });
}

// Usage in component
function HabitList() {
  const { data: habits, isLoading, error } = useHabits(user.id);
  const createHabit = useCreateHabit();
  
  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div>
      {habits.map(habit => <HabitCard key={habit.id} habit={habit} />)}
      <button onClick={() => createHabit.mutate(newHabit)}>
        Add Habit
      </button>
    </div>
  );
}
```

## Decision Tree
```
Is the state...
├─ Used only in one component? → useState
├─ Shared between 2-3 close components? → Lift state up
├─ Global (auth, theme, settings)? → Context API
├─ Complex global state? → Zustand/Redux
└─ Fetched from API? → React Query/SWR
```

## Best Practices
- Prefer composition over prop drilling (max 2-3 levels)
- Keep state as local as possible
- Use React Query for all server state
- Memoize context values to prevent unnecessary re-renders
- Use selectors to avoid subscribing to entire store
- Avoid storing derived state (compute from existing state)

## See also:
- [306-react-vite-tailwind-rules.mdc](306-react-vite-tailwind-rules.mdc)
- [310-performance-optimization.mdc](310-performance-optimization.mdc)
