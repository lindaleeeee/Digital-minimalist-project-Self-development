---
description: Standardized error handling and exception management patterns
globs: ["**/*.java", "**/*.ts", "**/*.tsx"]
alwaysApply: false
---
# Error Handling Patterns

## Backend (Spring Boot)
```java
// Custom exception hierarchy
public class BusinessException extends RuntimeException {
  private final ErrorCode errorCode;
  public BusinessException(ErrorCode code, String message) { /* ... */ }
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {
  @ExceptionHandler(BusinessException.class)
  public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
    return ResponseEntity.status(e.getErrorCode().getStatus())
      .body(ErrorResponse.of(e));
  }
}
```

## Frontend (React)
```typescript
// Error boundary for React components
class ErrorBoundary extends React.Component { /* ... */ }

// API error handling with axios
axios.interceptors.response.use(
  response => response,
  error => {
    const { status, data } = error.response;
    // Handle different error types
    if (status === 401) router.push('/login');
    return Promise.reject(data);
  }
);
```

## Error Logging
- Log all errors with context (user ID, request ID, timestamp)
- Use structured logging (JSON format)
- Implement error tracking (Sentry, DataDog, etc.)
- Never expose sensitive data in error messages

## See also:
- [100-error-fixing-process.mdc](100-error-fixing-process.mdc)
- [103-api-design-rest-conventions.mdc](103-api-design-rest-conventions.mdc)
