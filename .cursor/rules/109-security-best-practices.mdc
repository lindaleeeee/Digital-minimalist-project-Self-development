---
description: Security best practices for application development and deployment
globs: 
alwaysApply: false
---
# Security Best Practices

## OWASP Top 10 Mitigation

### 1. Injection Prevention
```java
// Use parameterized queries (JPA/QueryDSL handles this)
@Query("SELECT h FROM Habit h WHERE h.userId = :userId")
List<Habit> findByUserId(@Param("userId") Long userId);

// Validate and sanitize user input
@Valid @RequestBody HabitRequest request

// Use bean validation
public class HabitRequest {
  @NotBlank
  @Size(min = 1, max = 100)
  @Pattern(regexp = "^[a-zA-Z0-9\\s\\-]+$")
  private String name;
}
```

### 2. Broken Authentication
- Implement account lockout (5 failed attempts, 15-minute lockout)
- Use strong password policies (min 12 chars, complexity requirements)
- Implement MFA for sensitive operations
- Rotate JWT tokens, use short expiration times
- Store passwords with bcrypt (cost factor 12+)

### 3. Sensitive Data Exposure
```java
// Encrypt sensitive data at rest
@Convert(converter = EncryptedStringConverter.class)
private String sensitiveField;

// Use HTTPS only (HSTS header)
Strict-Transport-Security: max-age=31536000; includeSubDomains

// Mask PII in logs
log.info("User email: {}", maskEmail(user.getEmail()));

// Don't expose sensitive data in API responses
@JsonIgnore
private String password;
```

### 4. XML External Entities (XXE)
- Disable XML external entity processing in parsers
- Use JSON instead of XML when possible

### 5. Broken Access Control
```java
// Check ownership before operations
public Habit updateHabit(Long habitId, Long userId, HabitUpdate update) {
  Habit habit = habitRepository.findById(habitId)
    .orElseThrow(() -> new NotFoundException("Habit not found"));
  
  if (!habit.getUserId().equals(userId)) {
    throw new ForbiddenException("Not authorized to update this habit");
  }
  
  // Proceed with update
}

// Use Spring Security method security
@PreAuthorize("hasRole('USER')")
@PostMapping("/api/habits")
public ResponseEntity<Habit> createHabit(@RequestBody HabitRequest request) { }
```

### 6. Security Misconfiguration
```yaml
# Disable unnecessary features
spring:
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration
  
# Secure headers
server:
  servlet:
    session:
      cookie:
        http-only: true
        secure: true
        same-site: strict
```

### 7. Cross-Site Scripting (XSS)
```typescript
// React automatically escapes by default
<div>{userInput}</div> // Safe

// Sanitize HTML if needed
import DOMPurify from 'dompurify';
const clean = DOMPurify.sanitize(dirtyHTML);

// Set Content Security Policy
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'
```

### 8. Insecure Deserialization
- Validate input before deserialization
- Use allowlist for deserializable classes
- Monitor deserialization failures

### 9. Using Components with Known Vulnerabilities
```bash
# Run security audit regularly
npm audit
./gradlew dependencyCheckAnalyze

# Keep dependencies up-to-date
npm update
./gradlew dependencyUpdates
```

### 10. Insufficient Logging & Monitoring
```java
// Log security events
log.warn("Failed login attempt for user: {}", username);
log.info("User {} accessed sensitive resource: {}", userId, resource);

// Alert on suspicious patterns
if (failedAttempts > 5) {
  alertService.sendSecurityAlert("Multiple failed login attempts");
}
```

## Security Headers
```java
@Configuration
public class SecurityConfig {
  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.headers()
      .contentSecurityPolicy("default-src 'self'")
      .and()
      .frameOptions().deny()
      .xssProtection().block(true)
      .and()
      .contentTypeOptions()
      .and()
      .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN);
    
    return http.build();
  }
}
```

## API Security

### Rate Limiting
```java
// Using Bucket4j
@GetMapping("/api/habits")
@RateLimited(permits = 100, duration = 1, unit = TimeUnit.MINUTES)
public List<Habit> getHabits() { }
```

### CORS Configuration
```java
@Configuration
public class CorsConfig {
  @Bean
  public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("https://app.digital-minimalist.com"));
    config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
    config.setAllowedHeaders(List.of("Authorization", "Content-Type"));
    config.setAllowCredentials(true);
    
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);
    return source;
  }
}
```

## Security Checklist
- [ ] All inputs validated and sanitized
- [ ] Authentication and authorization implemented
- [ ] Sensitive data encrypted at rest and in transit
- [ ] Security headers configured
- [ ] CORS properly configured
- [ ] Rate limiting implemented
- [ ] Dependency vulnerabilities scanned
- [ ] Security logging and monitoring active
- [ ] Secrets not committed to version control
- [ ] HTTPS enforced in production

## See also:
- [104-security-oauth2-rules.mdc](104-security-oauth2-rules.mdc)
- [106-environment-configuration.mdc](106-environment-configuration.mdc)
- [203-logging-standards.mdc](203-logging-standards.mdc)
